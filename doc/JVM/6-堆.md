# 堆 heap
`java.lang.OutOfMemoryError: Java heap space`   
java中堆又分为eden和old，eden为新生区，old为老年区。
## eden
eden可以细分为eden区、幸存区Survivor（s0和s1），s0也叫to区，s1也叫from区，每次垃圾回收gc时s0和s1会交换位置。   
eden和s0、s1所占比例为8：1：1 
## Minor GC
Minor GC也叫轻gc，主要是对新生区进行垃圾回收。回收算法是复制算法。  
年轻代使用这种算法进行gc 。将可用的内存按容量划分为大小相等的两块（from，to），每次只是用其中一块（总有一块是空的【to区域】）。当这一苦熬的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已使用过的内存空间一次清理完。
HotSpot虚拟机默认Eden和Survivor大小的比例是8:1，也就是每次新生代中可用的内存空间为整个新生代容量的90%，只有10%的内存时被浪费的。
通常情况下新生代中对象生命周期很短，大部分对象都要被回收，从而 GC吞吐量要求很高，所以新生代适合使用复制算法来进行GC，这样保证复制的数据的量较小，效率最好。
缺点：浪费内存空间，如果对象存活率较高时要执行较多的复制操作，效率降低。  
### 算法过程：

1. Eden+S0可分配新生对象；

2. 对Eden+S0进行垃圾收集，存活对象复制到S1。清理Eden+S0。一次新生代GC结束。

3. Eden+S1可分配新生对象；

4. 对Eden+S1进行垃圾收集，存活对象复制到S0。清理Eden+S1。二次新生代GC结束。

5. goto 1。

默认Eden:S0:S1=8:1:1,因此，新生代中可以使用的内存空间大小占用新生代的9/10,那么有人就会问，为什么不直接分成两个区，一个区占9/10,另一个区占1/10，这样做的原因大概有以下几种

1.S0与S1的区间明显较小，有效新生代空间为Eden+S0/S1，因此有效空间就大，增加了内存使用率

2.有利于对象代的计算，当一个对象在S0/S1中达到设置的XX:MaxTenuringThreshold值后，会将其分到老年代中，设想一下，如果没有S0/S1,直接分成两个区，该如何计算对象经过了多少次GC还没被释放,你可能会说，在对象里加一个计数器记录经过的GC次数，或者存在一张映射表记录对象和GC次数的关系，是的，可以，但是这样的话，会扫描整个新生代中的对象, 有了S0/S1我们就可以只扫描S0/S1区

## 老年区

### full gc

## 永久区（jdk1.8之后移到元空间）
元空间在取代永久代之后，唯一的不同之处在于，元空间所占用的内存为本地内存，不在是JVM申请的内存，所以只要机器还有内存，元空间就可以一直申请使用。

**ps：关于元空间、永久区（永久代）、方法区的概念，方法区是JVM定义的一种规范，元空间是JDK1.8后对方法区一种实现，永久区是JDK1.8之前对方法区的一种实现，JDK1.8后用元空间取代了永久区**